# Use cases
## Authoring Environment
1. **User changes a tower's range**: When the user clicks "Apply", an event handler will trigger a listener in AuthoringController to call the `applyChange` method, which will trigger the AuthoringModel to change the necessary instance variable (towerRange) in the AuthoringTower class. The correct AuthoringTower will be chosen based on the Tower's String name/ID.
2. **User is satisfied with their game and clicks "Demo."**: The AuthoringController has a listener on the "Demo" button. When the "Demo" button is clicked, AuthoringController invokes FileIO's FileWriter to save the state of the objects in the AuthoringModel. ChiefController has a listener on a BooleanProperty in AuthoringController which is changed when the state of the AuthoringModel has been successfully changed - upon which the ChiefController instantiates a new instance of game play using the path to the file with the AuthoringModel state that was saved. 
3. **User clicks "Demo" but has an incomplete path in their game.** Because the user cannot click "Apply" to temporarily change his or her changes with an incomplete path still on the screen, the most recently saved temporary game will be Demoed, and all changes not "Applied" will be lost. This protocol will be communicated to the user at the beginning of game authoring.
4.  **User creates a new kind of tower available during gameplay**: When the user clicks "Apply", an event handler will trigger a listener in AuthoringController to call the `applyChange` method, which will create a `new AuthoringTower()` populated with the necessary instance variables based on the user's input. 
5.  **User loads in new image file to depict an enemy:** When the user chooses the "new image" option, a menu to enter the filepath (or perhaps to navigate using the user's existing filesystem) of the new image. Once selected, a listener in ChiefController will trigger FileIO to save the image in the proper location in the game authoring filesystem. When the user clicks "Apply", an event handler will trigger a listener in AuthoringController to call the `applyChange` method, which will trigger the AuthoringModel to change the ImageView instance variable in the AuthoringTower class.  
6.  **User adds a new path to the level:** A new path object is created when the user hits the _create a path_ button. The user will be asked first to place the starting points and the end points for the path. Then the user can drag and drop path node objects into the view to connect the path. The path object will check to see that the start positions all connect to an end position before an _apply_ button becomes enabled. The apply button will reassign the path in the `AuthoringModel.java` class to be used in the game.
7.  **User wants another level but is too lazy to populate custom settings (auto-generate new levels):** Once the user launches the authoring environment, they can input the number of levels the want in a textfield. Beneath this input field there's also a checkbox that denotes _Consistent Level Layout_. If this is checked, the user will only need to generate one level layout that will be used for each level of the game. If the box is unchecked the user will have to generate each level individually through the authoring environment. 
8.  User wants to customize how many enemy "waves" there are, and the composition of those waves: The user is asked how many waves to include in each level. Then a menu to customize the wave is presented for each wave. The menu asks the user to input how many enemies should be included in the wave. This information is stored on the front end initially. A new menu is presented that allows the user to specify the number of each type of enemy in the level. The enemies available will be stored in `AuthoringModel.java`. Once the user specifies the amount for each enemy, the `AuthoringView.java` class ensures that the number for each enemy type sums to the total number of enemies in the wave. A new `Wave` object is created that holds the enemy types and the number associated with each. This object will be attached to the level being authored. 
9. User wants to return to main menu to start over without saving: The user clicks the _Home_ button. This brings up a pop up display notifying the user that they will lose information. There are two buttons, one to _save_ and one to _exit_. If they select _exit_ the original menu screen is loaded. If they select _save_, a screen is created for them to name the game and save it. 
10. **User wants to specify which kind of attack ability a tower has (i.e. freezing, shooting, etc.)**: Upon creation of the DropdownMenu object (wrapping a ComboBox) that represents the tower attack type within the AuthoringView class, a Listener is placed on the user selection of an option in the DropdownMenu. A BooleanProperty instance variable in the AuthoringView class is listened to by AuthoringController; this BooleanProperty is changed when the user makes a selection, and separate AuthoringView instance variables are populated with information about the field the user changed (tower ability) and the value to which the user changed it. AuthoringController calls methods to get these values from AuthoringView when the BooleanProperty changes. AuthoringController then calls the `applyChange` method in AuthoringModel, which then applies an ability change to the appropriate Tower object.  
11. **User is in "Demo" mode and wants to return back to editing the game**: ChiefController is notified when the Return to Authoring/Editing button is clicked, upon which it switches its Scene from that provided by PlayController to that provided by AuthoringController. AuthoringController uses FileIO to load in the state of the authoring environment that the user previously left in order to demo. 
12. **User wants to specify custom starting value for player health:** Upon creation of the Resources screen, a Listener is placed on the "Apply" button at the bottom of the screen. A BooleanProperty instance variable in the AuthoringView class is listened to by AuthoringController; this BooleanProperty is changed when the user clicks the "Apply" button on the Resources screen. AuthoringController calls methods to get the values from the instance variables in the AuthoringView's Resources screen when the BooleanProperty changes. AuthoringController then calls the `applyChange` method in AuthoringModel, which then applies a change in health to the Resources object (along with the other changes that have been made to fields in the Resources screen).  
13. **User loads in a new background image**: FileChooser opens from the SettingsScreen, and the selected File is added to the library of background images that the user can choose from. Noting that a user action has occurred, the AuthoringController updates the SettingsScreen. Upon this update, AuthoringController ensures that FileIO is invoked to get the newest list of the files in the background images folder, which will be provided to SettingsScreen. SettingsScreen may then use the List of Files to create Image objects to display background image options to the user. 
14. **Designer changes the tower's damage**: For the designer to change a tower's damage, they must choose the Tower feature to edit. From there they are given the option to load in a previously defined tower or to create the a new one. Either way, the next step is to define the various attributes of the tower. One of these is damage. The designer can enter the desired value in a text field which will call setDamage(double damage) on the newly created Tower object.
15. **Designer changes the tower's cost**: See above use case, but change tower cost attribute instead of damage.
16. **Designer wants to add a custom theme song**: The custom theme song is a potential utility we discussed we haven't yet dicussed its implementation.
17. **Designer changes enemies' penalty to health (damage)**: The designer selects an enemy as feature to edit and edits its attributes to change its damage. This causes the AuthoringModel to instantiate a new (or edit an old) Enemy object and use setDamage(double damage)
18. **User is in Demo mode and would like to toggle back to the authoring environment**: The "Return to Authoring" button will only appear in gameplay when the Game Engine is instantiated as a result of pressing the "Demo" button (a different subclass of the Game Engine will be instantiated). This button will have a listener on in which will trigger ChiefController to instantiate the authoring environment and load in the game that was previously being played. Then, the AuthoringController can work as normal to allow continued editing of the game.
19. **User wants to delete an element of the path (drags a path block to the trash icon)**: Once the user clicks "Apply", the listener on the Apply button triggers Authoring Controller to call the Authoring Model, which then removes the Path object from its List of objects. 
20. **User wants to make a path but is too lazy to click and drag path elements one by one (can drag the path block)**: If the user right clicks to drag a block rather than left clicking, and the mouse hovers over a region not populated by a block, AuthoringController triggers AuthoringModel to create a new PathBlock objects and add it to the list of PathBlock objects contained in the current Level.

## Engine/GamePlay
21. **User clicks ‘Start’ to initiate play:** The user clicks the start button and a window pops up, requesting the user to choose an XML file. Once the user selects a filepath, the program calls the XML reader createEngine() method, which draws information from the XML file at the specified filepath to create an instance of a game engine that is capable of applying the rules outlined in the XML file. A Game Loop is also instantiated based on the engine that is created, allowing the program to display the GUI. The game is now ready to be played.
22. **User chooses to play game with misformatted file:** The user clicks the start button and a window pops up, requesting the user choose an XML file. The user chooses a file that is not of the correct format and clicks “ok.” A pop up window appears stating that the selected file is of the incorrect format. The user exits out of the window and must select a new file of the correct format.**