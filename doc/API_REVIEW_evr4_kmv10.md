# Erik:
## Part 1:
* What about your API/design is intended to be flexible?:  For the path builder scene I currently have an interface for the path objects that is implemented in a pathObject class and pathcomposite class in order to make adding and manipulating new path objects to the scene more flexible. We also have various screen/panel interfaces that new screen classes can implement so that adding new screens is flexible.
* How is your API/design encapsulating your implementation decisions?: Having the Path interface implements the composite design pattern for path objects.
* How is your part linked to other parts of the project?: The path builder scene is linked to the rest of the front end as it is threaded in with other scenes that must connect to each other (through next/back buttons). Also the information regarding the path objects (including location in scene and imageview) needs to get passed to FileIO which then gets passed to game engine so that the user constructed levels are correctly implemented in game engine.
* What exceptions (error cases) might occur in your part and how will you handle them (or not, by throwing)?: Errors need to be thrown if the user tries to change the size of the path images to incompatible sizes (such as negative) or any other User input that is not compatible.
* Why do you think your API/design is good (also define what your measure of good is)?: I think the API design is good since many parts of the project implement interfaces so that adding most front end components are flexible and easily added by implementing an interface.
Part 2:
* Discuss the use cases/issues that you are responsible for: are they descriptive, appropriate, reasonably sized?: I’m responsible for the use cases regarding the path builder, such as adding a path block to the scene, choosing multiple path blocks to delete or to copy and paste, etc...I believe they are reasonably sized and styled as they are descriptive and cover many issues that need to be covered by the path builder.
* Estimate how long you think each will take and why. What, if anything, makes estimating these tasks uncertain?: I think implementing the rest of the use cases will take about 10 hours but then the rest of the time will be spent integrating the code as a team in order for the entire project to function.
* What feature/design problem are you most excited to work on?: I’m most excited to try to implement a “drag to select” and then delete or copy and paste functionality to the blocks in the scene.
* What feature/design problem are you most worried about working on?: I’m most worried about changing the size of the objects in the grid as you have to accommodate for adding new rows/columns to fit the designated space of the gridpane and also change the size of the path objects currently in the grid. This will require manipulating various elements in the classes so all the logic that makes up this functionality works together.
* What major feature do you plan to implement this weekend?: I plan to finish with all of the implementation of the path builder so that the rest of the time can be spent better integrating code with the rest of the front end along with the game engine team and working through bugs.

# Katie:
## Part 1:
* What about your API/design is intended to be flexible?: Our Backend Engine API is constructed to be flexible in adding multiple types of Sprites, or actors, within the game. Sprites currently encompass towers, enemies, and projectiles, but can be extended to easily include landscape objects and other types of game components.
* How is your API/design encapsulating your implementation decisions?: We’ve created interfaces that encapsulate different parts of the program such as moving, intersecting, and handling multiple types of towers/enemies/projectiles using a composite design pattern (through our Manager classes).
* How is your part linked to other parts of the project?: The Backend engine communicates with the GamePlayer through a Mediator class, which contains interfaces that hide certain information from parts of the program that don’t need it (such as the backend components). 
* What exceptions (error cases) might occur in your part and how will you handle them (or not, by throwing)?: Our part will have to handle null cases (such as when Towers aren’t placed) and should throw an error when the User doesn’t place enough towers. The Engine should also handle throwing an error for when a Tower is placed inappropriately. 
* Why do you think your API/design is good (also define what your measure of good is)?: I think our API design is good because it limits information passing between components that don’t need to know certain things about each other, such as the frontend and backend. It also leverages the Composite and Mediator design patterns to streamline communication between different parts and encapsulate information such as looping. 
Part 2:
* Discuss the use cases/issues that you are responsible for: are they descriptive, appropriate, reasonably sized?: The Use cases are descriptive and appropriate, however, I think that they could benefit from more detailed descriptions about exactly what the use case entails regarding classes. 
* Estimate how long you think each will take and why. What, if anything, makes estimating these tasks uncertain?: I think that each use case will take approximately 5-10 hours per person to complete. I think the uncertainty comes from integration, since a lot of use cases involve making multiple parts work together. 
* What feature/design problem are you most excited to work on?: I’m most excited to work on the Property classes, especially for when we start to integrate new challenges that’ll test the flexibility of the Property class.
* What feature/design problem are you most worried about working on?: I’m most worried working on integration, especially between the Engine and the GamePlayer. 
* What major feature do you plan to implement this weekend?: We plan to implement the Tower classes, and updating them from the frontend to the backend.
